각 알고리즘에 대한 설계 근거와 시간 복잡성 분석을 포함한 종합적인 설명이 필요합니다. 라는데, 이를 quick sort에 대해서 자세히 설명해줘
# 6. Quick Sort
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)
그리고, 이 코드를 바탕으로 무엇을 어떤 부분에 적용시켰는지 같은 스타일로 부탁해
이미 있던 내용에 코드에 대한 언급을 추가해달라는 소리야
시간복잡도에 대한설명과, 코드분석에 대한 내용을 자세하게 부탁해

병합 정렬(Merge Sort)
병합 정렬은 분할 정복(Divide and Conquer) 전략에 기반한 대표적인 정렬 알고리즘으로, 전체 배열을 절반으로 나누고 각각을 재귀적으로 정렬한 뒤 병합하는 방식으로 동작한다. 이러한 방식은 문제를 작은 단위로 분해하여 해결하는 구조적 장점을 가지며, logn크기의 분할트리만큼의 분할작업이 고정적으로 일어나므로 항상 일정한 시간 복잡도를 보장한다.

병합 정렬의 시간 복잡도는 모든 경우에 대해 O(n log n)으로, 입력 크기가 n인 배열을 log n 단계로 분할하고(분할 트리로 나타내면 트리의 크기가 log n), 배열을 합치는 과정에서 모든 요소가 한번씩 비교를 해야하기 때문에, O(n)의 시간복잡도가 병합에서 나타난다. 
다만, 병합 과정에서 새로운 배열을 사용해야 하므로 공간 복잡도는 O(n)으로 다소 비효율적일 수 있다.
(코드 사진)
이 코드에서 mergeSort 함수는 배열을 재귀적으로 분할하고, merge 함수는 두 개의 정렬된 배열을 하나로 병합하는 역할을 한다. 특히 merge 함수 내에서 (left[i] <= right[j]) 조건을 통해 같은 값을 가진 원소가 앞에 있는 배열에서 먼저 선택되므로 안정성이 자연스럽게 유지된다. 또한, 새로운 리스트 result에 병합 결과를 저장하므로, 정렬이 in-place로 수행되지 않으며 추가적인 메모리를 사용하는 구조임을 확인할 수 있다.

힙 정렬(Heap Sort)은 완전 이진 트리 기반의 힙(Heap) 자료구조를 활용한 정렬 알고리즘이다. 입력 배열을 최대 힙 구조로 변환한 뒤, 루트 노드(최댓값)를 배열의 끝으로 이동시키고, 남은 부분에 대해 반복적으로 힙을 재구성함으로써 정렬을 수행한다. 힙 구성 단계의 시간 복잡도는 O(n), 정렬 과정의 시간 복잡도는 O(n log n)으로(각 heapify가 O(logn)의 시간이 걸리기 때문에), 전체적인 시간 복잡도는 최악·최선·평균 경우 모두 O(n log n)을 보장한다. 추가적인 메모리를 사용하지 않아 공간 복잡도는 O(1)이며, 비교 기반 정렬 중에서도 일관된 성능을 보인다. 그러나 Heapify 과정에서는 값의 크기만 비교하고, 원래의 입력 순서는 고려하지 않기 때문에 원소들의 상대적 순서가 바뀔 수 있어 안정 정렬은 아니다.
(코드 사진)
본 구현에서는 heapify 함수를 사용하여 힙의 구조를 유지하며, 먼저 전체 배열을 힙으로 구성한 뒤(for i in range(n // 2 - 1, -1, -1)), 루트 노드를 하나씩 배열 끝으로 보내고 남은 힙을 재정렬하는 방식으로 정렬을 수행하였다. 이 방식은 힙 정렬의 동작 원리를 명확하게 보여주며, 알고리즘 설계 및 복잡도 분석에 근거한 구조적 구현이라 할 수 있다.

버블 정렬(Bubble Sort)은 인접한 두 원소를 반복적으로 비교하고, 순서가 잘못된 경우 교환함으로써 정렬을 수행하는 단순 비교 기반 정렬 알고리즘이다. 이 알고리즘은 가장 큰(또는 작은) 값을 차례로 배열 끝으로 밀어내는 방식으로 동작하며, 전체 배열을 여러 번 반복 탐색하여 정렬을 완료한다. 알고리즘의 설계는 직관적이고 구현이 간단하다는 장점이 있으며, 입력 데이터가 이미 거의 정렬되어 있을 경우 비교 횟수가 줄어들 수 있다.

버블 정렬의 시간 복잡도는 입력 데이터의 초기 정렬 상태에 따라 달라진다. 최악의 경우, 입력 배열이 완전히 역순으로 정렬되어 있는 경우에는 모든 인접 원소쌍에 대해 비교와 교환이 발생하므로, 총 비교 횟수는 n(n−1)/2에 해당하며 시간 복잡도는 O(n^2)이다. 평균적인 경우에도 배열이 임의의 순서로 주어졌을 때 대부분의 원소쌍에 대해 비교가 필요하므로, 마찬가지로 시간 복잡도는 O(n^2)로 분석된다. 반면, 최선의 경우는 입력 배열이 이미 정렬되어 있는 상황이다. 이때는 한 차례의 순회만으로 정렬 여부를 확인할 수 있으며, 교환이 한 번도 발생하지 않는다는 조건을 플래그로 감지하여 알고리즘을 조기에 종료할 수 있다. 이러한 개선이 적용되면 최선의 경우 시간 복잡도는 O(n)으로 감소한다.
공간 복잡도는 O(1)로 추가적인 메모리를 사용하지 않으며, 인접한 원소끼리 교환만 수행하기 때문에 안정 정렬이다. 즉, 같은 값을 가지는 원소들의 상대적 순서가 유지된다.
(코드 사진)
본 구현에서는 배열의 길이를 기준으로 두 개의 반복문을 사용하였으며, 내부 루프에서 인접 원소 arr[j]와 arr[j+1]를 비교하여 정렬이 필요한 경우 두 값을 교환하였다. 이 구조는 버블 정렬의 기본 원리를 잘 반영하며, 매 반복마다 가장 큰 값이 정렬되지 않은 영역의 끝으로 이동하도록 설계되었다. 본 코드는 버블 정렬 알고리즘의 작동 방식과 시간 복잡도 분석을 직관적으로 보여준다.

삽입 정렬(Insertion Sort)은 정렬된 부분 배열에 새로운 원소를 한 개씩 삽입하여 전체 배열을 정렬하는 방식의 알고리즘이다. 카드 게임에서 손에 든 패를 정렬하는 방식과 유사하게, 왼쪽에서 오른쪽으로 배열을 순회하면서 현재 원소를 정렬된 부분 배열의 적절한 위치에 삽입하는 구조로 설계되었다. 이러한 방식은 구현이 간단하고, 특히 입력 데이터가 거의 정렬되어 있는 경우 매우 효율적으로 동작한다는 장점이 있다.

삽입 정렬의 시간 복잡도는 입력 데이터의 정렬 상태에 따라 다음과 같이 나뉜다.

최악의 경우는 배열이 역순으로 정렬된 경우이며, 이 경우 각 원소는 정렬된 부분의 맨 앞까지 이동해야 하므로 전체 비교 및 이동 횟수는 n(n−1)/2에 해당하며, 시간 복잡도는 O(n^2)이다.
평균의 경우도 마찬가지로 O(n^2)의 시간 복잡도를 가진다.
최선의 경우는 이미 정렬된 배열로, 이 경우 비교만 수행되고 이동이 발생하지 않아 시간 복잡도는 O(n)으로 감소한다.

삽입 정렬은 추가적인 메모리를 사용하지 않으며(공간 복잡도 O(1)), 안정 정렬이기도 하다. 삽입 정렬이 안정한 이유는, 같은 값을 가진 두 원소가 있을 경우 먼저 등장한 원소가 나중에 등장한 원소보다 앞에 위치하도록 비교 시 > 조건을 사용하는 방식으로 구현되기 때문이다. 즉, 값이 같을 경우 원래의 순서를 유지한 채 삽입되므로 상대적 순서가 바뀌지 않는다. 이는 정렬 후에도 원소들의 원래 순서 정보를 보존해야 하는 경우에 매우 중요한 특성이다.

본 구현에서는 배열을 인덱스 1부터 순회하면서, 해당 원소를 기준으로 왼쪽 정렬된 부분에서 자신의 위치를 찾아 삽입하는 방식으로 작성되었다. key 값을 기준으로, 그보다 큰 값들은 한 칸씩 뒤로 밀어내며 while 루프에서 적절한 삽입 위치를 탐색한다. 

선택 정렬(Selection Sort)은 배열 내에서 가장 작은(또는 가장 큰) 원소를 선택하여 정렬되지 않은 부분의 앞쪽과 교환하는 방식으로 동작하는 정렬 알고리즘이다. 알고리즘의 기본 아이디어는 간단하고 직관적이며, 정렬되지 않은 배열에서 매 단계마다 최소값을 선택하여 맨 앞으로 옮기는 방식으로 설계되었다. 이 알고리즘은 추가적인 메모리를 거의 사용하지 않으며, 구현이 쉬워 교육적인 목적으로 자주 사용된다.

시간 복잡도는 입력의 정렬 상태와 무관하게 항상 일정하다.

최악의 경우, 최선의 경우, 평균적인 경우 모두 동일하게 O(n 2)의 시간 복잡도를 갖는다.
이는 모든 원소에 대해 나머지 원소들과 비교를 수행해야 하기 때문이다. 각 반복마다 최소값을 찾기 위해 최대 n−i−1번의 비교가 필요하고, 전체 반복이 𝑛n번 수행되므로 총 비교 횟수는∑ i=1n−1​ i= 2 n(n−1) 가 되어 O(n 2 )에 해당한다.

반면, 교환 연산은 최대 n−1번만 수행되어 버블 정렬이나 삽입 정렬보다 교환 횟수가 적은 편이다.

다만 선택 정렬은 불안정 정렬이다. 그 이유는 교환 과정에서 동일한 값을 가진 원소 간의 상대적인 순서가 바뀔 수 있기 때문이다. 예를 들어, 동일한 값이 앞뒤에 존재하더라도 최소값을 앞으로 가져오기 위해 뒤쪽 값을 앞으로 옮기는 과정에서 앞쪽 값이 뒤로 밀릴 수 있다.

제공된 코드는 선택 정렬의 기본적인 구조를 그대로 구현한 것이다. 배열의 길이 n을 기준으로 외부 루프를 통해 각 인덱스 i를 순회하고, 내부 루프에서는 i+1부터 n-1까지의 원소 중 가장 작은 값의 인덱스를 min_idx에 저장한다. 그 후, arr[i]와 arr[min_idx]를 교환하여 정렬되지 않은 부분에서 가장 작은 원소를 앞쪽으로 옮긴다. 이 과정을 통해 배열 전체가 정렬될 때까지 반복하며, 시간 복잡도는 O(n 2 )로 유지된다.

퀵 정렬(Quick Sort)은 분할 정복(Divide and Conquer) 방식을 사용하여 배열을 정렬하는 효율적인 알고리즘입니다. 이 알고리즘은 피벗(pivot)을 기준으로 배열을 분할하고, 각 분할된 배열을 재귀적으로 정렬하는 방식으로 작동합니다. 

퀵 정렬의 핵심 아이디어는 배열에서 피벗을 선택하고, 피벗을 기준으로 배열을 두 개의 서브 배열로 나누는 것입니다. 하나는 피벗보다 작은 값들을 포함하고, 다른 하나는 피벗보다 큰 값들을 포함합니다. 이렇게 분할된 배열에 대해 재귀적으로 퀵 정렬을 적용하여 배열을 정렬합니다. 이 과정은 배열의 크기가 1 이하가 될 때까지 반복되며, 결국 정렬된 배열을 반환합니다.
퀵 정렬의 시간 복잡도는 배열의 크기와 피벗의 선택에 따라 달라집니다. 최악의 경우는 배열이 이미 정렬되어 있거나 역순으로 정렬되어 있을 때 발생합니다. 이 경우, 퀵 정렬은 배열을 매번 한 원소만 분할하게 되어 O(n²) 의 시간 복잡도를 가집니다. 평균적인 경우는 배열이 잘 분할되어 O(n log n) 의 시간 복잡도를 가지며, 이는 퀵 정렬의 가장 중요한 특징 중 하나입니다. 최선의 경우는 피벗이 배열을 정확히 반으로 분할할 수 있을 때 발생하며, 이 경우도 시간 복잡도는 **O(n log n)**입니다.
이 알고리즘은 불안정 정렬로 분류됩니다. 동일한 값이 여러 번 등장할 경우, 그들의 상대적인 순서가 변경될 수 있기 때문입니다. 예를 들어, 동일한 값을 가진 원소들이 피벗과 비교되어 위치가 바뀌면, 원래의 상대적인 순서가 보장되지 않으므로 불안정한 정렬이 됩니다.
퀵 정렬의 공간 복잡도는 주로 재귀 호출에 의한 추가적인 메모리 사용으로 인해 O(n) 입니다. 퀵 정렬은 배열을 분할하여 작업하므로, 비교적 적은 추가 공간을 사용하며 효율적으로 동작합니다. 
(코드 사진)
제공된 퀵 정렬 코드에서는 피벗을 배열의 중간 값으로 설정하고 있습니다 (pivot = arr[len(arr) // 2]). 이 방식은 코드 구현을 간결하게 하며 평균적인 경우에 잘 동작하지만, 피벗의 선택이 배열의 정렬 성능에 영향을 미칠 수 있습니다. 피벗이 배열의 중간 값으로 설정될 경우, 배열이 고르게 분할되어 성능이 좋지만, 이미 정렬된 배열이나 역순 배열에서 이 방법은 O(n²) 의 시간 복잡도를 초래할 수 있습니다. 이는 피벗이 최악의 경우 배열의 한쪽 끝 값이 되어 분할이 균등하게 이루어지지 않기 때문입니다. 따라서 피벗 선택에 따라 퀵 정렬의 성능이 달라질 수 있습니다. 예를 들어, 피벗을 랜덤으로 선택하거나 첫 번째 또는 마지막 원소를 선택하는 방법 등 다양한 방법을 사용하여 최악의 경우를 방지하려는 최적화 기법들이 존재합니다.

라이브러리정렬은 삽입정렬에서 삽입하는 과정을 더 매끄럽게 만든 정렬로, bst와 유사하게 이진탐색을 이용하여 삽입할 장소를 찾아 속도를 단축시킨게 특징이다. 또한, 배열내 요소 사이에 공간이 없어 재배열이 일어나는 현상을 막기위해 더 넓은 배열을 사용한다. 삽입할때 바로 옆에 삽입하는 것이 아니라 빈공간을 의도적으로 남겨놓아, 이후 삽입에도 재배열이 최소화되도록 유도한다.


